# 有序数组的平方

难度：简单

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]

```

**提示：**

- `1 <= nums.length <= 104`
- `104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

**进阶：**

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题

通过次数283,207提交次数409,988

## 解题：

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& a) {
        int k = a.size() - 1;
        vector<int> b(a.size(), 0);
        for(int i = 0, j = a.size() - 1; i <= j; ) {
            if(a[j] * a[j] < a[i] * a[i]) {
                b[k--] = a[i] * a[i];
                i++;
            } else {
                b[k--] = a[j] * a[j];
                j--;
            }
        }
        return b;
    }
};
```

## 题解：

本题目其实可以直接暴力解决，但是暴力解决的时间复杂度为O(n^2)，直接使用两个for循环即可得出结果。现采用双指针法，将时间复杂度控制在O(n)级别，即一个指针指向头部，一个指向尾部，因为原数组给的是有序数列，那么需要寻找第一个最大值时，只有可能是第一个值和最后一个值，第一个值是负数，平方后是有可能比最后一个数的平方更大的，那么以此类推，第二个最大值也可能通过此方法判断，即得出以上解决方案。